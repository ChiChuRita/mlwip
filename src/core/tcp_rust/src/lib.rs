// TCP Rust Implementation Library
// Main library entry point for lwip_tcp_rust

// Include FFI bindings generated by build.rs
#[cfg(not(test))]
#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
pub(crate) mod ffi {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// For tests, we need to provide mock FFI types and functions
#[cfg(test)]
#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
pub(crate) mod ffi {
    // Mock FFI types for testing
    pub type ip_addr_t = [u8; 20];
    pub type netif = u8;

    #[repr(C)]
    pub struct tcp_hdr {
        pub src: u16,
        pub dest: u16,
        pub seqno: u32,
        pub ackno: u32,
        pub _hdrlen_rsvd_flags: u16,
        pub wnd: u16,
        pub chksum: u16,
        pub urgp: u16,
    }

    #[repr(C)]
    pub struct pbuf {
        pub next: *mut pbuf,
        pub payload: *mut core::ffi::c_void,
        pub tot_len: u16,
        pub len: u16,
        pub type_: u8,
        pub flags: u8,
        pub ref_: u8,
    }

    // TCP flags
    pub const TCP_FIN: u32 = 0x01;
    pub const TCP_SYN: u32 = 0x02;
    pub const TCP_RST: u32 = 0x04;
    pub const TCP_PSH: u32 = 0x08;
    pub const TCP_ACK: u32 = 0x10;
    pub const TCP_URG: u32 = 0x20;

    // Mock pbuf layer and type constants
    pub const pbuf_layer_PBUF_TRANSPORT: u32 = 0;
    pub const pbuf_type_PBUF_RAM: u32 = 0;

    // Mock functions - these will panic if called in tests
    pub unsafe fn pbuf_alloc(_layer: u32, _length: u16, _type: u32) -> *mut pbuf {
        panic!("pbuf_alloc should not be called in tests");
    }

    pub unsafe fn pbuf_free(_p: *mut pbuf) {
        // No-op for tests
    }
}

pub mod state;
pub mod control_path;
pub mod tcp_in;
pub mod tcp_out;

// Re-export commonly used types
pub use state::{TcpState, TcpConnectionState};
pub use control_path::{TcpFlags, TcpSegment, ControlPath};
