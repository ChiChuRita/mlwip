/* automatically generated by rust-bindgen 0.69.5 */

pub const PBUF_POOL_SIZE: u32 = 8;
pub const PBUF_LINK_HLEN: u32 = 16;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const IP_PROTO_TCP: u32 = 6;
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type err_t = s8_t;
#[doc = " Includes spare room for transport layer header, e.g. UDP header.\n Use this if you intend to pass the pbuf to functions like udp_send()."]
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 56;
#[doc = " Includes spare room for IP header.\n Use this if you intend to pass the pbuf to functions like raw_send()."]
pub const pbuf_layer_PBUF_IP: pbuf_layer = 36;
#[doc = " Includes spare room for link layer header (ethernet header).\n Use this if you intend to pass the pbuf to functions like ethernet_output().\n @see PBUF_LINK_HLEN"]
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 16;
#[doc = " Includes spare room for additional encapsulation header before ethernet\n headers (e.g. 802.11).\n Use this if you intend to pass the pbuf to functions like netif->linkoutput().\n @see PBUF_LINK_ENCAPSULATION_HLEN"]
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 0;
#[doc = " Use this for input packets in a netif driver when calling netif->input()\n in the most common case - ethernet-layer netif driver."]
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 0;
#[doc = " @ingroup pbuf\n Enumeration of pbuf layers"]
pub type pbuf_layer = ::core::ffi::c_uint;
#[doc = " pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload\nare allocated in one piece of contiguous memory (so the first payload byte\ncan be calculated from struct pbuf).\npbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might\nchange in future versions).\nThis should be used for all OUTGOING packets (TX)."]
pub const pbuf_type_PBUF_RAM: pbuf_type = 640;
#[doc = " pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in\ntotally different memory areas. Since it points to ROM, payload does not\nhave to be copied when queued for transmission."]
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
#[doc = " pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change\nso it has to be duplicated when queued before transmitting, depending on\nwho has a 'ref' to it."]
pub const pbuf_type_PBUF_REF: pbuf_type = 65;
#[doc = " pbuf payload refers to RAM. This one comes from a pool and should be used\nfor RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct\npbuf and its payload are allocated in one piece of contiguous memory (so\nthe first payload byte can be calculated from struct pbuf).\nDon't use this for TX, if the pool becomes empty e.g. because of TCP queuing,\nyou are unable to receive TCP acks!"]
pub const pbuf_type_PBUF_POOL: pbuf_type = 386;
#[doc = " @ingroup pbuf\n Enumeration of pbuf types"]
pub type pbuf_type = ::core::ffi::c_uint;
#[doc = " Main packet buffer struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " a bit field indicating pbuf type and allocation sources\n(see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)"]
    pub type_internal: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u8_t,
    #[doc = " For incoming packets, this contains the input netif's index"]
    pub if_idx: u8_t,
}
#[test]
fn bindgen_test_layout_pbuf() {
    const UNINIT: ::core::mem::MaybeUninit<pbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pbuf>(),
        24usize,
        concat!("Size of: ", stringify!(pbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<pbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(pbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tot_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        18usize,
        concat!("Offset of field: ", stringify!(pbuf), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_internal) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(type_internal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).if_idx) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(if_idx)
        )
    );
}
impl Default for pbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ip4_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip4_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip4_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " ip4_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip4_addr_t as well as on ip4_addr_p_t."]
pub type ip4_addr_t = ip4_addr;
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
pub type ip_addr_t = ip4_addr_t;
pub type mem_size_t = u16_t;
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut ::core::ffi::c_void);
}
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet\n @return ERR_OK if the packet was handled\n         != ERR_OK is the packet was NOT handled, in this case, the caller has\n                   to free the pbuf"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually etharp_output()"]
    pub output: netif_output_fn,
    #[doc = " This function is called by ethernet_output() when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device."]
    pub state: *mut ::core::ffi::c_void,
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " flags (@see @ref netif_flags)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface. Used for @ref if_api and @ref netifapi_netif,\n as well as for IPv6 zones"]
    pub num: u8_t,
}
#[test]
fn bindgen_test_layout_netif() {
    const UNINIT: ::core::mem::MaybeUninit<netif> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif>(),
        72usize,
        concat!("Size of: ", stringify!(netif))
    );
    assert_eq!(
        ::core::mem::align_of::<netif>(),
        8usize,
        concat!("Alignment of ", stringify!(netif))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gw) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(netif), "::", stringify!(gw))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkoutput) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(linkoutput)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr_len) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(num)
        )
    );
}
impl Default for netif {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ip4_output_if(
        p: *mut pbuf,
        src: *const ip4_addr_t,
        dest: *const ip4_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
extern "C" {
    pub fn ip_chksum_pseudo(
        p: *mut pbuf,
        proto: u8_t,
        proto_len: u16_t,
        src: *const ip_addr_t,
        dest: *const ip_addr_t,
    ) -> u16_t;
}
#[doc = " Function prototype for a timeout callback function. Register such a function\n using sys_timeout().\n\n @param arg Additional argument to pass to the function - set up by sys_timeout()"]
pub type sys_timeout_handler =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    pub fn sys_timeout(msecs: u32_t, handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn sys_untimeout(handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
}
