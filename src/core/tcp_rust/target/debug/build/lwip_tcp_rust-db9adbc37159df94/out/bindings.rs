/* automatically generated by rust-bindgen 0.69.5 */

pub const PBUF_POOL_SIZE: u32 = 8;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 16;
pub const TCP_TTL: u32 = 255;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 536;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_BUF: u32 = 1072;
pub const TCP_SND_QUEUELEN: u32 = 8;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 536;
pub const TCP_RCV_SCALE: u32 = 0;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const TCP_DEBUG: u32 = 0;
pub const TCP_INPUT_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_OUTPUT_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const IP_PROTO_TCP: u32 = 6;
pub const TCP_WRITE_FLAG_COPY: u32 = 1;
pub const TCP_WRITE_FLAG_MORE: u32 = 2;
pub const TCP_PRIO_MIN: u32 = 1;
pub const TCP_PRIO_NORMAL: u32 = 64;
pub const TCP_PRIO_MAX: u32 = 127;
pub const TCP_ALLFLAGS: u32 = 65535;
pub const TCP_SNDQUEUELEN_OVERFLOW: u32 = 65532;
pub const TCP_HLEN: u32 = 20;
pub const TCP_FIN: u32 = 1;
pub const TCP_SYN: u32 = 2;
pub const TCP_RST: u32 = 4;
pub const TCP_PSH: u32 = 8;
pub const TCP_ACK: u32 = 16;
pub const TCP_URG: u32 = 32;
pub const TCP_ECE: u32 = 64;
pub const TCP_CWR: u32 = 128;
pub const TCP_FLAGS: u32 = 63;
pub const TCP_MAX_OPTION_BYTES: u32 = 40;
pub const TCP_TMR_INTERVAL: u32 = 250;
pub const TCP_FAST_INTERVAL: u32 = 250;
pub const TCP_SLOW_INTERVAL: u32 = 500;
pub const TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const TCP_SYN_RCVD_TIMEOUT: u32 = 20000;
pub const TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const TCP_MSL: u32 = 60000;
pub const TCP_KEEPIDLE_DEFAULT: u32 = 7200000;
pub const TCP_KEEPINTVL_DEFAULT: u32 = 75000;
pub const TCP_KEEPCNT_DEFAULT: u32 = 9;
pub const TCP_MAXIDLE: u32 = 675000;
pub const TCP_OVERSIZE_DBGCHECK: u32 = 0;
pub const TCP_DEBUG_PCB_LISTS: u32 = 0;
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type err_t = s8_t;
#[doc = " Includes spare room for transport layer header, e.g. UDP header.\n Use this if you intend to pass the pbuf to functions like udp_send()."]
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 56;
#[doc = " Includes spare room for IP header.\n Use this if you intend to pass the pbuf to functions like raw_send()."]
pub const pbuf_layer_PBUF_IP: pbuf_layer = 36;
#[doc = " Includes spare room for link layer header (ethernet header).\n Use this if you intend to pass the pbuf to functions like ethernet_output().\n @see PBUF_LINK_HLEN"]
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 16;
#[doc = " Includes spare room for additional encapsulation header before ethernet\n headers (e.g. 802.11).\n Use this if you intend to pass the pbuf to functions like netif->linkoutput().\n @see PBUF_LINK_ENCAPSULATION_HLEN"]
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 0;
#[doc = " Use this for input packets in a netif driver when calling netif->input()\n in the most common case - ethernet-layer netif driver."]
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 0;
#[doc = " @ingroup pbuf\n Enumeration of pbuf layers"]
pub type pbuf_layer = ::core::ffi::c_uint;
#[doc = " pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload\nare allocated in one piece of contiguous memory (so the first payload byte\ncan be calculated from struct pbuf).\npbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might\nchange in future versions).\nThis should be used for all OUTGOING packets (TX)."]
pub const pbuf_type_PBUF_RAM: pbuf_type = 640;
#[doc = " pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in\ntotally different memory areas. Since it points to ROM, payload does not\nhave to be copied when queued for transmission."]
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
#[doc = " pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change\nso it has to be duplicated when queued before transmitting, depending on\nwho has a 'ref' to it."]
pub const pbuf_type_PBUF_REF: pbuf_type = 65;
#[doc = " pbuf payload refers to RAM. This one comes from a pool and should be used\nfor RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct\npbuf and its payload are allocated in one piece of contiguous memory (so\nthe first payload byte can be calculated from struct pbuf).\nDon't use this for TX, if the pool becomes empty e.g. because of TCP queuing,\nyou are unable to receive TCP acks!"]
pub const pbuf_type_PBUF_POOL: pbuf_type = 386;
#[doc = " @ingroup pbuf\n Enumeration of pbuf types"]
pub type pbuf_type = ::core::ffi::c_uint;
#[doc = " Main packet buffer struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " a bit field indicating pbuf type and allocation sources\n(see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)"]
    pub type_internal: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u8_t,
    #[doc = " For incoming packets, this contains the input netif's index"]
    pub if_idx: u8_t,
}
#[test]
fn bindgen_test_layout_pbuf() {
    const UNINIT: ::core::mem::MaybeUninit<pbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pbuf>(),
        24usize,
        concat!("Size of: ", stringify!(pbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<pbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(pbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tot_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        18usize,
        concat!("Offset of field: ", stringify!(pbuf), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_internal) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(type_internal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).if_idx) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(if_idx)
        )
    );
}
impl Default for pbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ip4_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip4_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip4_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " ip4_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip4_addr_t as well as on ip4_addr_p_t."]
pub type ip4_addr_t = ip4_addr;
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
pub type ip_addr_t = ip4_addr_t;
pub type mem_size_t = u16_t;
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut ::core::ffi::c_void);
}
pub const memp_t_MEMP_RAW_PCB: memp_t = 0;
pub const memp_t_MEMP_UDP_PCB: memp_t = 1;
pub const memp_t_MEMP_TCP_PCB: memp_t = 2;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 3;
pub const memp_t_MEMP_TCP_SEG: memp_t = 4;
pub const memp_t_MEMP_REASSDATA: memp_t = 5;
pub const memp_t_MEMP_FRAG_PBUF: memp_t = 6;
pub const memp_t_MEMP_NETBUF: memp_t = 7;
pub const memp_t_MEMP_NETCONN: memp_t = 8;
pub const memp_t_MEMP_TCPIP_MSG_API: memp_t = 9;
pub const memp_t_MEMP_TCPIP_MSG_INPKT: memp_t = 10;
pub const memp_t_MEMP_SYS_TIMEOUT: memp_t = 11;
pub const memp_t_MEMP_PBUF: memp_t = 12;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 13;
pub const memp_t_MEMP_MAX: memp_t = 14;
#[doc = " Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end"]
pub type memp_t = ::core::ffi::c_uint;
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut ::core::ffi::c_void);
}
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet\n @return ERR_OK if the packet was handled\n         != ERR_OK is the packet was NOT handled, in this case, the caller has\n                   to free the pbuf"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually etharp_output()"]
    pub output: netif_output_fn,
    #[doc = " This function is called by ethernet_output() when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device."]
    pub state: *mut ::core::ffi::c_void,
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " flags (@see @ref netif_flags)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface. Used for @ref if_api and @ref netifapi_netif,\n as well as for IPv6 zones"]
    pub num: u8_t,
}
#[test]
fn bindgen_test_layout_netif() {
    const UNINIT: ::core::mem::MaybeUninit<netif> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif>(),
        72usize,
        concat!("Size of: ", stringify!(netif))
    );
    assert_eq!(
        ::core::mem::align_of::<netif>(),
        8usize,
        concat!("Alignment of ", stringify!(netif))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gw) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(netif), "::", stringify!(gw))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkoutput) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(linkoutput)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr_len) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(num)
        )
    );
}
impl Default for netif {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ip4_output_if(
        p: *mut pbuf,
        src: *const ip4_addr_t,
        dest: *const ip4_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
extern "C" {
    pub fn ip_chksum_pseudo(
        p: *mut pbuf,
        proto: u8_t,
        proto_len: u16_t,
        src: *const ip_addr_t,
        dest: *const ip_addr_t,
    ) -> u16_t;
}
pub type tcpwnd_size_t = u16_t;
pub const tcp_state_CLOSED: tcp_state = 0;
pub const tcp_state_LISTEN: tcp_state = 1;
pub const tcp_state_SYN_SENT: tcp_state = 2;
pub const tcp_state_SYN_RCVD: tcp_state = 3;
pub const tcp_state_ESTABLISHED: tcp_state = 4;
pub const tcp_state_FIN_WAIT_1: tcp_state = 5;
pub const tcp_state_FIN_WAIT_2: tcp_state = 6;
pub const tcp_state_CLOSE_WAIT: tcp_state = 7;
pub const tcp_state_CLOSING: tcp_state = 8;
pub const tcp_state_LAST_ACK: tcp_state = 9;
pub const tcp_state_TIME_WAIT: tcp_state = 10;
pub type tcp_state = ::core::ffi::c_uint;
#[doc = " Function prototype for tcp accept callback functions. Called when a new\n connection can be accepted on a listening pcb.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param newpcb The new connection pcb\n @param err An error code if there has been an error accepting.\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_accept_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, newpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
#[doc = " Function prototype for tcp receive callback functions. Called when data has\n been received.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which received data\n @param p The received data (or NULL when the connection has been closed!)\n @param err An error code if there has been an error receiving\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        tpcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp sent callback functions. Called when sent data has\n been acknowledged by the remote side. Use it to free corresponding resources.\n This also means that the pcb has now space available to send new data.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb for which data has been acknowledged\n @param len The amount of bytes acknowledged\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_sent_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, len: u16_t) -> err_t,
>;
#[doc = " Function prototype for tcp poll callback functions. Called periodically as\n specified by @see tcp_poll.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb tcp pcb\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_poll_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " Function prototype for tcp error callback functions. Called when the pcb\n receives a RST or is unexpectedly closed for any other reason.\n\n @note The corresponding pcb is already freed when this callback is called!\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param err Error code to indicate why the pcb has been closed\n            ERR_ABRT: aborted through tcp_abort or by a TCP timer\n            ERR_RST: the connection was reset by the remote host"]
pub type tcp_err_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, err: err_t)>;
#[doc = " Function prototype for tcp connected callback functions. Called when a pcb\n is connected to the remote side after initiating a connection attempt by\n calling tcp_connect().\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which is connected\n @param err An unused error code, always ERR_OK currently ;-) @todo!\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!\n\n @note When a connection attempt fails, the error callback is currently called!"]
pub type tcp_connected_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, tpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
pub type tcpflags_t = u16_t;
#[doc = " the TCP protocol control block for listening pcbs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb_listen {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub netif_idx: u8_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb_listen,
    pub callback_arg: *mut ::core::ffi::c_void,
    pub state: tcp_state,
    pub prio: u8_t,
    pub local_port: u16_t,
    pub rust_handle: *mut ::core::ffi::c_void,
    pub accept: tcp_accept_fn,
}
#[test]
fn bindgen_test_layout_tcp_pcb_listen() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_pcb_listen> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_pcb_listen>(),
        56usize,
        concat!("Size of: ", stringify!(tcp_pcb_listen))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_pcb_listen>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_pcb_listen))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netif_idx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(netif_idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).so_options) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(so_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_arg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(callback_arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rust_handle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(rust_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accept) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(accept)
        )
    );
}
impl Default for tcp_pcb_listen {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " the TCP protocol control block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub netif_idx: u8_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb,
    pub callback_arg: *mut ::core::ffi::c_void,
    pub state: tcp_state,
    pub prio: u8_t,
    pub local_port: u16_t,
    pub rust_handle: *mut ::core::ffi::c_void,
    pub remote_port: u16_t,
    pub flags: tcpflags_t,
    pub polltmr: u8_t,
    pub pollinterval: u8_t,
    pub last_timer: u8_t,
    pub tmr: u32_t,
    pub rcv_nxt: u32_t,
    pub rcv_wnd: tcpwnd_size_t,
    pub rcv_ann_wnd: tcpwnd_size_t,
    pub rcv_ann_right_edge: u32_t,
    pub rtime: s16_t,
    pub mss: u16_t,
    pub rttest: u32_t,
    pub rtseq: u32_t,
    pub sa: s16_t,
    pub sv: s16_t,
    pub rto: s16_t,
    pub nrtx: u8_t,
    pub dupacks: u8_t,
    pub lastack: u32_t,
    pub cwnd: tcpwnd_size_t,
    pub ssthresh: tcpwnd_size_t,
    pub rto_end: u32_t,
    pub snd_nxt: u32_t,
    pub snd_wl1: u32_t,
    pub snd_wl2: u32_t,
    pub snd_lbb: u32_t,
    pub snd_wnd: tcpwnd_size_t,
    pub snd_wnd_max: tcpwnd_size_t,
    pub snd_buf: tcpwnd_size_t,
    pub snd_queuelen: u16_t,
    pub unsent_oversize: u16_t,
    pub bytes_acked: tcpwnd_size_t,
    pub unsent: *mut tcp_seg,
    pub unacked: *mut tcp_seg,
    pub ooseq: *mut tcp_seg,
    pub refused_data: *mut pbuf,
    pub listener: *mut tcp_pcb_listen,
    pub sent: tcp_sent_fn,
    pub recv: tcp_recv_fn,
    pub connected: tcp_connected_fn,
    pub poll: tcp_poll_fn,
    pub errf: tcp_err_fn,
    pub keep_idle: u32_t,
    pub persist_cnt: u8_t,
    pub persist_backoff: u8_t,
    pub persist_probe: u8_t,
    pub keep_cnt_sent: u8_t,
}
#[test]
fn bindgen_test_layout_tcp_pcb() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_pcb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_pcb>(),
        224usize,
        concat!("Size of: ", stringify!(tcp_pcb))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_pcb>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_pcb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netif_idx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(netif_idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).so_options) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(so_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_arg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(callback_arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rust_handle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rust_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).polltmr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(polltmr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollinterval) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(pollinterval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_timer) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(last_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(tmr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_nxt) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_nxt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_wnd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_ann_wnd) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_ann_wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_ann_right_edge) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_ann_right_edge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtime) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rtime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mss) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(mss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rttest) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rttest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtseq) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rtseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sv) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rto) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrtx) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(nrtx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dupacks) as usize - ptr as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(dupacks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastack) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(lastack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cwnd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(cwnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssthresh) as usize - ptr as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rto_end) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rto_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_nxt) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_nxt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wl1) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wl2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wl2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_lbb) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_lbb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wnd) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wnd_max) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wnd_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_buf) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_queuelen) as usize - ptr as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_queuelen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unsent_oversize) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unsent_oversize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_acked) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(bytes_acked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unsent) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unsent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unacked) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unacked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ooseq) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ooseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refused_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(refused_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listener) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sent) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errf) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(errf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keep_idle) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(keep_idle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_cnt) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_backoff) as usize - ptr as usize },
        221usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_backoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_probe) as usize - ptr as usize },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_probe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keep_cnt_sent) as usize - ptr as usize },
        223usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(keep_cnt_sent)
        )
    );
}
impl Default for tcp_pcb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn tcp_recved(pcb: *mut tcp_pcb, len: u16_t);
}
extern "C" {
    pub fn tcp_output(pcb: *mut tcp_pcb) -> err_t;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_hdr {
    pub src: u16_t,
    pub dest: u16_t,
    pub seqno: u32_t,
    pub ackno: u32_t,
    pub _hdrlen_rsvd_flags: u16_t,
    pub wnd: u16_t,
    pub chksum: u16_t,
    pub urgp: u16_t,
}
#[test]
fn bindgen_test_layout_tcp_hdr() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(tcp_hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seqno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(seqno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ackno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(ackno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._hdrlen_rsvd_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(_hdrlen_rsvd_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wnd) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chksum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(chksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).urgp) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(urgp)
        )
    );
}
extern "C" {
    pub fn tcp_alloc(prio: u8_t) -> *mut tcp_pcb;
}
extern "C" {
    pub fn tcp_free(pcb: *mut tcp_pcb);
}
extern "C" {
    pub fn tcp_abandon(pcb: *mut tcp_pcb, reset: ::core::ffi::c_int);
}
extern "C" {
    pub fn tcp_send_empty_ack(pcb: *mut tcp_pcb) -> err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_seg {
    pub next: *mut tcp_seg,
    pub p: *mut pbuf,
    pub len: u16_t,
    pub flags: u8_t,
    pub tcphdr: *mut tcp_hdr,
}
#[test]
fn bindgen_test_layout_tcp_seg() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_seg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_seg>(),
        32usize,
        concat!("Size of: ", stringify!(tcp_seg))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_seg>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_seg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_seg),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_seg),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_seg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_seg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcphdr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_seg),
            "::",
            stringify!(tcphdr)
        )
    );
}
impl Default for tcp_seg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut tcp_ticks: u32_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_listen_pcbs_t {
    pub listen_pcbs: *mut tcp_pcb_listen,
    pub pcbs: *mut tcp_pcb,
}
#[test]
fn bindgen_test_layout_tcp_listen_pcbs_t() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_listen_pcbs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_listen_pcbs_t>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_listen_pcbs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_listen_pcbs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_listen_pcbs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listen_pcbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_listen_pcbs_t),
            "::",
            stringify!(listen_pcbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pcbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_listen_pcbs_t),
            "::",
            stringify!(pcbs)
        )
    );
}
impl Default for tcp_listen_pcbs_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut tcp_bound_pcbs: *mut tcp_pcb;
}
extern "C" {
    pub static mut tcp_listen_pcbs: tcp_listen_pcbs_t;
}
extern "C" {
    pub static mut tcp_active_pcbs: *mut tcp_pcb;
}
extern "C" {
    pub static mut tcp_tw_pcbs: *mut tcp_pcb;
}
extern "C" {
    pub static tcp_pcb_lists: [*mut *mut tcp_pcb; 4usize];
}
extern "C" {
    pub fn tcp_enqueue_flags(pcb: *mut tcp_pcb, flags: u8_t) -> err_t;
}
extern "C" {
    pub fn tcp_next_iss(pcb: *mut tcp_pcb) -> u32_t;
}
extern "C" {
    pub fn tcp_recv_null(
        arg: *mut ::core::ffi::c_void,
        pcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t;
}
#[doc = " Function prototype for a timeout callback function. Register such a function\n using sys_timeout().\n\n @param arg Additional argument to pass to the function - set up by sys_timeout()"]
pub type sys_timeout_handler =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    pub fn sys_timeout(msecs: u32_t, handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn sys_untimeout(handler: sys_timeout_handler, arg: *mut ::core::ffi::c_void);
}
